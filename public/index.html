<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clash of Clans - Player Comparison</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="coc_max_levels.js"></script>
  </head>
  <body>
    <div id="dashboards" class="dashboard-container">
      <p id="loading-message" class="info-message">Loading player data...</p>
    </div>

    <script>
      /**
       * This code was entirely developed with the assistance of an AI (Google Gemini).
       * It includes data fetching, processing, dynamic HTML generation,
       * Chart.js integration for visualizations, and CSS styling.
       */

      // --- Helper function to get max level for an item based on TH/BH ---
      // Moved outside the async IIFE so it's accessible globally
      function getThMaxLevelForItem(
        category,
        itemName,
        thLevel,
        builderBase = false
      ) {
        if (builderBase) {
          if (
            COC_MAX_LEVELS_BY_TH.builderBase[category] &&
            COC_MAX_LEVELS_BY_TH.builderBase[category][itemName]
          ) {
            return (
              COC_MAX_LEVELS_BY_TH.builderBase[category][itemName][thLevel] || 0
            );
          }
        } else {
          if (
            COC_MAX_LEVELS_BY_TH[category] &&
            COC_MAX_LEVELS_BY_TH[category][itemName]
          ) {
            return COC_MAX_LEVELS_BY_TH[category][itemName][thLevel] || 0;
          }
        }
        return 0; // Return 0 if data not found for that TH level
      }

      (async () => {
        const container = document.getElementById("dashboards");
        const loadingMessage = document.getElementById("loading-message");

        loadingMessage.style.display = "block";
        container.innerHTML = "";

        const players = [
          { name: "Tony Stark", tag: "#Y9PQCJ02L" },
          { name: "tvl", tag: "#22QCVQ8Y" },
        ];

        try {
          const fetchPromises = players.map((player) =>
            axios
              .get(
                `https://coc.lourenco-jplm1818.workers.dev/?id=${player.name}`
              )
              .then((response) => ({ name: player.name, data: response.data }))
          );

          const results = await Promise.all(fetchPromises);

          loadingMessage.style.display = "none";

          const playerTony = results.find(
            (p) => p.name.toLowerCase() === "tony stark"
          )?.data;
          const playerTVL = results.find(
            (p) => p.name.toLowerCase() === "tvl"
          )?.data;

          if (!playerTony || !playerTVL) {
            container.innerHTML = `
              <p class="error-message">
                Error: Could not retrieve complete data for Tony Stark or TVL.
                Please check if player names are correct or if data is available.
              </p>
            `;
            return;
          }

          const comparisonCategories = ["troops", "spells", "heroes"];
          const comparisonData = {};

          for (const category of comparisonCategories) {
            const tonyItems = playerTony[category] || [];
            const tvlItems = playerTVL[category] || [];

            const itemNames = new Set([
              ...tonyItems.map((i) => i.name),
              ...tvlItems.map((i) => i.name),
            ]);

            comparisonData[category] = [];

            for (const itemName of itemNames) {
              const tonyItem = tonyItems.find((i) => i.name === itemName);
              const tvlItem = tvlItems.find((i) => i.name === itemName);

              const tonyLevel = tonyItem?.level || 0;
              const tvlLevel = tvlItem?.level || 0;

              // Max level from API (absolute max)
              const maxLevelAbsolute = Math.max(
                tonyItem?.maxLevel || 0,
                tvlItem?.maxLevel || 0
              );

              // Max level for current Town Hall
              let maxLevelTonyForTH = getThMaxLevelForItem(
                category,
                itemName,
                playerTony.townHallLevel,
                false
              );
              let maxLevelTVLForTH = getThMaxLevelForItem(
                category,
                itemName,
                playerTVL.townHallLevel,
                false
              );

              // Handle Builder Base items if any are present in the main API response lists
              if (
                tonyItem?.village === "builderBase" ||
                tvlItem?.village === "builderBase"
              ) {
                maxLevelTonyForTH = getThMaxLevelForItem(
                  category,
                  itemName,
                  playerTony.builderHallLevel,
                  true
                );
                maxLevelTVLForTH = getThMaxLevelForItem(
                  category,
                  itemName,
                  playerTVL.builderHallLevel,
                  true
                );
              }

              let winner = "draw";
              if (tonyLevel > tvlLevel) {
                winner = "tony";
              } else if (tvlLevel > tonyLevel) {
                winner = "tvl";
              }

              const tonyIsMaxForTH =
                tonyLevel > 0 && tonyLevel === maxLevelTonyForTH;
              const tvlIsMaxForTH =
                tvlLevel > 0 && tvlLevel === maxLevelTVLForTH;

              const tonyIsAbsoluteMax =
                tonyLevel > 0 && tonyLevel === maxLevelAbsolute;
              const tvlIsAbsoluteMax =
                tvlLevel > 0 && tvlLevel === maxLevelAbsolute;

              const itemIsAbsoluteMaxOverall =
                tonyLevel === maxLevelAbsolute &&
                tvlLevel === maxLevelAbsolute &&
                maxLevelAbsolute > 0;

              comparisonData[category].push({
                name: itemName,
                tonyLevel: tonyLevel,
                tvlLevel: tvlLevel,
                maxLevelAbsolute: maxLevelAbsolute,
                maxLevelTonyForTH: maxLevelTonyForTH,
                maxLevelTVLForTH: maxLevelTVLForTH,
                winner: winner,
                tonyIsMaxForTH: tonyIsMaxForTH,
                tvlIsMaxForTH: tvlIsMaxForTH,
                tonyIsAbsoluteMax: tonyIsAbsoluteMax,
                tvlIsAbsoluteMax: tvlIsAbsoluteMax,
                itemIsAbsoluteMaxOverall: itemIsAbsoluteMaxOverall,
              });
            }
          }

          // --- Functions to Generate HTML Sections ---

          const createComparisonTableSection = (
            title,
            icon,
            list,
            player1Name,
            player2Name
          ) => {
            return `
              <h3>${icon} ${title}</h3>
              <table class="compare-table">
                <thead>
                  <tr>
                    <th>${player1Name}</th>
                    <th>Item</th>
                    <th>${player2Name}</th>
                  </tr>
                </thead>
                <tbody>
                  ${list
                    .map((item) => {
                      let classTony = "",
                        classTVL = "";
                      let itemDisplayName = item.name;

                      if (item.itemIsAbsoluteMaxOverall) {
                        itemDisplayName = `${item.name} 🔥`;
                      }

                      if (item.winner === "tony") {
                        classTony = "highlight-green";
                        classTVL = "highlight-red";
                      } else if (item.winner === "tvl") {
                        classTony = "highlight-red";
                        classTVL = "highlight-green";
                      } else {
                        classTony = classTVL = "highlight-blue";
                      }

                      const tonyPulseClass = item.tonyIsAbsoluteMax
                        ? "max-level-pulse"
                        : "";
                      const tvlPulseClass = item.tvlIsAbsoluteMax
                        ? "max-level-pulse"
                        : "";

                      let tonyLevelText = `Level ${item.tonyLevel} / ${item.maxLevelAbsolute}`;
                      if (item.tonyIsAbsoluteMax) {
                        tonyLevelText += ` 🔥`;
                        if (
                          item.maxLevelTonyForTH > 0 &&
                          item.maxLevelTonyForTH !== item.maxLevelAbsolute
                        )
                          tonyLevelText += ` (TH Max: ${item.maxLevelTonyForTH})`;
                      } else if (item.tonyIsMaxForTH) {
                        tonyLevelText += ` ✅`;
                        if (item.maxLevelTonyForTH > 0)
                          tonyLevelText += ` (TH Max: ${item.maxLevelTonyForTH})`;
                      }

                      let tvlLevelText = `Level ${item.tvlLevel} / ${item.maxLevelAbsolute}`;
                      if (item.tvlIsAbsoluteMax) {
                        tvlLevelText += ` 🔥`;
                        if (
                          item.maxLevelTVLForTH > 0 &&
                          item.maxLevelTVLForTH !== item.maxLevelAbsolute
                        )
                          tvlLevelText += ` (TH Max: ${item.maxLevelTVLForTH})`;
                      } else if (item.tvlIsMaxForTH) {
                        tvlLevelText += ` ✅`;
                        if (item.maxLevelTVLForTH > 0)
                          tvlLevelText += ` (TH Max: ${item.maxLevelTVLForTH})`;
                      }

                      const tonyProgressBar =
                        item.tonyLevel < item.maxLevelAbsolute &&
                        item.maxLevelAbsolute > 0
                          ? `<progress class="level-progress" value="${item.tonyLevel}" max="${item.maxLevelAbsolute}"></progress>`
                          : "";
                      const tvlProgressBar =
                        item.tvlLevel < item.maxLevelAbsolute &&
                        item.maxLevelAbsolute > 0
                          ? `<progress class="level-progress" value="${item.tvlLevel}" max="${item.maxLevelAbsolute}"></progress>`
                          : "";

                      return `
                        <tr>
                          <td class="${classTony} ${tonyPulseClass}">
                            <div class="level-info-wrapper">
                                ${tonyLevelText}
                                ${tonyProgressBar}
                            </div>
                          </td>
                          <td>${itemDisplayName}</td>
                          <td class="${classTVL} ${tvlPulseClass}">
                            <div class="level-info-wrapper">
                                ${tvlLevelText}
                                ${tvlProgressBar}
                            </div>
                          </td>
                        </tr>`;
                    })
                    .join("")}
                </tbody>
              </table>
            `;
          };

          const createHeroEquipmentSection = (equipment, playerName) => {
            if (!equipment || equipment.length === 0) {
              return `<p class="info-message">No hero equipment found for ${playerName}.</p>`;
            }
            let equipmentList = equipment
              .map((equip) => {
                const progressBar =
                  equip.level < equip.maxLevel && equip.maxLevel > 0
                    ? `<progress class="level-progress-compact" value="${equip.level}" max="${equip.maxLevel}"></progress>`
                    : "";
                const isAbsoluteMax =
                  equip.level > 0 && equip.level === equip.maxLevel;
                const isMaxPulseClass = isAbsoluteMax
                  ? "max-level-pulse-compact"
                  : "";
                const levelIcon = isAbsoluteMax ? " 🔥" : "";

                return `
                <tr>
                  <td class="${isMaxPulseClass}">
                    ${equip.name}
                    <br>
                    Level ${equip.level} / ${equip.maxLevel}${levelIcon}
                    ${progressBar}
                  </td>
                </tr>
              `;
              })
              .join("");

            return `
              <div class="player-details-card">
                <h4>Hero Equipment</h4>
                <table class="compact-table">
                  <tbody>
                    ${equipmentList}
                  </tbody>
                </table>
              </div>
            `;
          };

          const createAchievementsSection = (
            achievements,
            playerName,
            villageType = "home"
          ) => {
            const filteredAchievements = achievements.filter(
              (a) => a.village === villageType
            );
            const topCompleted = filteredAchievements
              .filter((a) => a.stars === 3)
              .slice(0, 5);
            const topUncompleted = filteredAchievements
              .filter((a) => a.stars < 3)
              .slice(0, 5);

            let achievementList = [...topCompleted, ...topUncompleted]
              .map((achievement) => {
                const completionValue = achievement.value || 0;
                const completionTarget = achievement.target || 1;

                const progressBar =
                  completionValue < completionTarget && completionTarget > 0
                    ? `<progress class="level-progress-compact" value="${completionValue}" max="${completionTarget}"></progress>`
                    : "";

                const isAbsoluteMax = achievement.stars === 3;
                const isMaxPulseClass = isAbsoluteMax
                  ? "max-level-pulse-compact"
                  : "";
                const levelIcon = isAbsoluteMax ? " 🔥" : "";

                return `
                <tr>
                  <td class="${isMaxPulseClass}">
                    ${achievement.name}
                    <br>
                    Stars: ${achievement.stars} / ${
                  achievement.targetStars || 3
                }${levelIcon}
                    ${progressBar}
                  </td>
                </tr>
              `;
              })
              .join("");

            if (!achievementList) {
              return `<p class="info-message">No achievements found for ${playerName}.</p>`;
            }

            return `
              <div class="player-details-card">
                <h4>${
                  villageType === "home"
                    ? "Home Village Achievements"
                    : "Builder Base Achievements"
                }</h4>
                <table class="compact-table">
                  <tbody>
                    ${achievementList}
                  </tbody>
                </table>
              </div>
            `;
          };

          const createLabelsSection = (labels, playerName) => {
            if (!labels || labels.length === 0) {
              return `<p class="info-message">No labels found for ${playerName}.</p>`;
            }
            let labelList = labels
              .map(
                (label) => `
              <tr>
                <td>${label.name}</td>
                <td><img src="${label.iconUrls.small}" alt="${label.name}" class="label-icon" /></td>
              </tr>
            `
              )
              .join("");

            return `
              <div class="player-details-card">
                <h4>Labels</h4>
                <table class="compact-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Icon</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${labelList}
                  </tbody>
                </table>
              </div>
            `;
          };

          const createClanDetailsSection = (clan, playerName) => {
            if (!clan) {
              return `<p class="info-message">${playerName} does not belong to a clan.</p>`;
            }
            return `
              <div class="player-details-card">
                <h4>Clan</h4>
                <p><strong>Name:</strong> ${clan.name || "N/A"}</p>
                <p><strong>Level:</strong> ${clan.clanLevel || "N/A"}</p>
                ${
                  clan.badgeUrls
                    ? `<img src="${clan.badgeUrls.small}" alt="Clan Badge" class="clan-badge" />`
                    : ""
                }
              </div>
            `;
          };

          const createLeagueDetailsSection = (league, playerName) => {
            if (!league) {
              return `<p class="info-info">No league found for ${playerName}.</p>`;
            }
            return `
              <div class="player-details-card">
                <h4>Main League</h4>
                <p><strong>Name:</strong> ${league.name || "N/A"}</p>
                ${
                  league.iconUrls
                    ? `<img src="${league.iconUrls.small}" alt="League Icon" class="league-icon" />`
                    : ""
                }
              </div>
            `;
          };

          const createBuilderBaseLeagueDetailsSection = (
            builderBaseLeague,
            playerName
          ) => {
            if (!builderBaseLeague) {
              return `<p class="info-message">${playerName} is not in any Builder Base league.</p>`;
            }
            return `
              <div class="player-details-card">
                <h4>Builder Base League</h4>
                <p><strong>Name:</strong> ${builderBaseLeague.name || "N/A"}</p>
              </div>
            `;
          };

          // --- Functions to Generate Charts with Chart.js ---
          const renderChart = (ctx, type, data, options) => {
            new Chart(ctx, {
              type: type,
              data: data,
              options: options,
            });
          };

          const generateLevelChartData = (
            categoryData,
            player1Name,
            player2Name
          ) => {
            const labels = categoryData.map((item) => {
              return item.itemIsAbsoluteMaxOverall
                ? `${item.name} 🔥`
                : item.name;
            });

            const datasets = [
              {
                label: `${player1Name} Current Level`,
                data: categoryData.map((item) => item.tonyLevel),
                backgroundColor: categoryData.map((item) =>
                  item.tonyIsAbsoluteMax
                    ? "rgba(255, 215, 0, 0.9)"
                    : "rgba(102, 255, 204, 0.9)"
                ),
                borderColor: categoryData.map((item) =>
                  item.tonyIsAbsoluteMax
                    ? "rgba(255, 215, 0, 1)"
                    : "rgba(102, 255, 204, 1)"
                ),
                borderWidth: 1,
                stack: "player1Stack",
              },
              {
                label: `${player1Name} To Max`,
                data: categoryData.map(
                  (item) => item.maxLevelAbsolute - item.tonyLevel
                ),
                backgroundColor: "rgba(102, 255, 204, 0.3)",
                borderColor: "rgba(102, 255, 204, 0.5)",
                borderWidth: 1,
                stack: "player1Stack",
              },
              {
                label: `${player2Name} Current Level`,
                data: categoryData.map((item) => item.tvlLevel),
                backgroundColor: categoryData.map((item) =>
                  item.tvlIsAbsoluteMax
                    ? "rgba(255, 215, 0, 0.9)"
                    : "rgba(255, 170, 170, 0.9)"
                ),
                borderColor: categoryData.map((item) =>
                  item.tvlIsAbsoluteMax
                    ? "rgba(255, 215, 0, 1)"
                    : "rgba(255, 170, 170, 1)"
                ),
                borderWidth: 1,
                stack: "player2Stack",
              },
              {
                label: `${player2Name} To Max`,
                data: categoryData.map(
                  (item) => item.maxLevelAbsolute - item.tvlLevel
                ),
                backgroundColor: "rgba(255, 170, 170, 0.3)",
                borderColor: "rgba(255, 170, 170, 0.5)",
                borderWidth: 1,
                stack: "player2Stack",
              },
            ];

            const maxOverallLevelForScale = Math.max(
              ...categoryData.map((item) => item.maxLevelAbsolute)
            );

            const options = {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: {
                    color: "#f0f0f0",
                    filter: function (item, chart) {
                      return !item.text.includes("To Max");
                    },
                  },
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      const itemIndex = context.dataIndex;
                      const dataLabel = context.dataset.label || "";
                      const currentLevelValue = context.parsed.y;
                      const itemName = labels[itemIndex].replace(" 🔥", "");

                      const isTony = dataLabel.includes(player1Name);
                      const playerItemData = categoryData[itemIndex];

                      const maxAbsolute = playerItemData.maxLevelAbsolute;
                      const maxForTH = isTony
                        ? playerItemData.maxLevelTonyForTH
                        : playerItemData.maxLevelTVLForTH;

                      if (dataLabel.includes("Current Level")) {
                        const isAbsoluteMax =
                          currentLevelValue > 0 &&
                          currentLevelValue === maxAbsolute;
                        const isMaxForTH =
                          currentLevelValue > 0 &&
                          currentLevelValue === maxForTH;

                        let tooltipText = `${itemName}: Level ${currentLevelValue}`;
                        if (maxAbsolute > 0) tooltipText += ` / ${maxAbsolute}`;

                        if (isAbsoluteMax) {
                          tooltipText += " 🔥";
                        } else if (isMaxForTH) {
                          tooltipText += " ✅";
                        }

                        if (maxForTH > 0 && maxForTH !== maxAbsolute) {
                          tooltipText += ` (TH Max: ${maxForTH})`;
                        }

                        return tooltipText;
                      } else if (dataLabel.includes("To Max")) {
                        return `${itemName} (To Max): ${currentLevelValue} (Absolute Max: ${maxAbsolute})`;
                      }
                      return `${dataLabel}: ${currentLevelValue}`;
                    },
                  },
                },
              },
              scales: {
                x: {
                  stacked: false,
                  ticks: {
                    color: "#f0f0f0",
                    maxRotation: 45,
                    minRotation: 45,
                  },
                  grid: {
                    color: "#444",
                  },
                },
                y: {
                  stacked: true,
                  beginAtZero: true,
                  max:
                    maxOverallLevelForScale > 0
                      ? maxOverallLevelForScale + 1
                      : 10,
                  ticks: {
                    color: "#f0f0f0",
                    stepSize: 1,
                  },
                  grid: {
                    color: "#444",
                  },
                },
              },
            };

            return { labels, datasets, options };
          };

          // --- Function to create the pending upgrades section ---
          const createPendingUpgradesSection = (playerData) => {
            const playerName = playerData.name;
            const thLevel = playerData.townHallLevel;
            const bhLevel = playerData.builderHallLevel;

            const pendingHomeVillage = [];
            const pendingBuilderBase = [];

            // Helper to check and add to pending list
            const checkAndAddPending = (
              list,
              item,
              itemCategory,
              currentLevel,
              maxLevelForTH,
              builderBase = false
            ) => {
              // Only add if maxLevelForTH is defined and greater than current level
              if (maxLevelForTH > 0 && currentLevel < maxLevelForTH) {
                list.push(
                  `${item.name} (Lv ${currentLevel} / ${maxLevelForTH})`
                );
              }
            };

            // Check Home Village troops
            (playerData.troops || [])
              .filter((item) => item.village === "home")
              .forEach((troop) => {
                const maxLevelForTH = getThMaxLevelForItem(
                  "troops",
                  troop.name,
                  thLevel,
                  false
                );
                checkAndAddPending(
                  pendingHomeVillage,
                  troop,
                  "troops",
                  troop.level,
                  maxLevelForTH
                );
              });

            // Check Home Village spells
            (playerData.spells || [])
              .filter((item) => item.village === "home")
              .forEach((spell) => {
                const maxLevelForTH = getThMaxLevelForItem(
                  "spells",
                  spell.name,
                  thLevel,
                  false
                );
                checkAndAddPending(
                  pendingHomeVillage,
                  spell,
                  "spells",
                  spell.level,
                  maxLevelForTH
                );
              });

            // Check Home Village heroes
            (playerData.heroes || [])
              .filter((item) => item.village === "home")
              .forEach((hero) => {
                const maxLevelForTH = getThMaxLevelForItem(
                  "heroes",
                  hero.name,
                  thLevel,
                  false
                );
                checkAndAddPending(
                  pendingHomeVillage,
                  hero,
                  "heroes",
                  hero.level,
                  maxLevelForTH
                );
              });

            // Check Builder Base troops
            (playerData.troops || [])
              .filter((item) => item.village === "builderBase")
              .forEach((troop) => {
                const maxLevelForBH = getThMaxLevelForItem(
                  "troops",
                  troop.name,
                  bhLevel,
                  true
                );
                checkAndAddPending(
                  pendingBuilderBase,
                  troop,
                  "troops",
                  troop.level,
                  maxLevelForBH
                );
              });

            // Check Builder Base heroes
            (playerData.heroes || [])
              .filter((item) => item.village === "builderBase")
              .forEach((hero) => {
                const maxLevelForBH = getThMaxLevelForItem(
                  "heroes",
                  hero.name,
                  bhLevel,
                  true
                );
                checkAndAddPending(
                  pendingBuilderBase,
                  hero,
                  "heroes",
                  hero.level,
                  maxLevelForBH
                );
              });

            // Construct HTML output
            let html = `
                  <div class="player-details-card pending-upgrades-card">
                      <h4>Pending Upgrades for TH${thLevel}/BH${bhLevel}</h4>
                      <h5>Home Village:</h5>
                      <ul>
              `;
            if (pendingHomeVillage.length > 0) {
              html += pendingHomeVillage
                .map((item) => `<li>➡️ ${item}</li>`)
                .join("");
            } else {
              html += `<li>All Home Village items are maxed for TH${thLevel}! 🎉</li>`;
            }
            html += `
                      </ul>
                      <h5>Builder Base:</h5>
                      <ul>
              `;
            if (pendingBuilderBase.length > 0) {
              html += pendingBuilderBase
                .map((item) => `<li>➡️ ${item}</li>`)
                .join("");
            } else {
              html += `<li>All Builder Base items are maxed for BH${bhLevel}! 🎉</li>`;
            }
            html += `
                      </ul>
                  </div>
              `;

            return html;
          };

          // Generating individual player details cards
          const tonyDetails = `
            <div class="player-individual-details">
                <h3>${playerTony.name}</h3>
                <p><strong>XP Level:</strong> 🌟 ${playerTony.expLevel}</p>
                <p><strong>Trophies:</strong> 🏆 ${
                  playerTony.trophies
                } (Best: ${playerTony.bestTrophies})</p>
                <p><strong>Attack Wins:</strong> ⚔️ ${playerTony.attackWins}</p>
                <p><strong>Defense Wins:</strong> 🛡️ ${
                  playerTony.defenseWins
                }</p>
                <p><strong>War Stars:</strong> ⭐ ${playerTony.warStars}</p>
                <p><strong>War Preference:</strong> ${
                  playerTony.warPreference === "in"
                    ? "Participating ✅"
                    : "Not Participating ❌"
                }</p>
                <p><strong>TH Weapon Level:</strong> 💥 Level ${
                  playerTony.townHallWeaponLevel || "N/A"
                } / ${
            COC_MAX_LEVELS_BY_TH.townHallWeaponLevels[
              playerTony.townHallLevel
            ] || "N/A"
          }</p>
                <p><strong>Clan Role:</strong> 🤝 ${
                  playerTony.role
                    ? playerTony.role.charAt(0).toUpperCase() +
                      playerTony.role.slice(1)
                    : "Member"
                }</p>
                <p><strong>Builder Hall Level:</strong> 🏠 ${
                  playerTony.builderHallLevel
                }</p>
                <p><strong>Builder Base Trophies:</strong> 🏅 ${
                  playerTony.builderBaseTrophies
                } (Best: ${playerTony.bestBuilderBaseTrophies})</p>
                <p><strong>Clan Capital Contributions:</strong> 💰 ${
                  playerTony.clanCapitalContributions
                }</p>
                <p><strong>Donations:</strong> 🎁 ${
                  playerTony.donations
                } (Received: ${playerTony.donationsReceived})</p>
                
                <hr class="card-separator">

                ${createHeroEquipmentSection(
                  playerTony.heroEquipment,
                  playerTony.name
                )}
                ${createAchievementsSection(
                  playerTony.achievements,
                  playerTony.name,
                  "home"
                )}
                ${createAchievementsSection(
                  playerTony.achievements,
                  playerTony.name,
                  "builderBase"
                )}
                ${createLabelsSection(playerTony.labels, playerTony.name)}
                
                <hr class="card-separator">

                <div class="player-details-sub-wrapper">
                    ${createClanDetailsSection(
                      playerTony.clan,
                      playerTony.name
                    )}
                    ${createLeagueDetailsSection(
                      playerTony.league,
                      playerTony.name
                    )}
                    ${createBuilderBaseLeagueDetailsSection(
                      playerTony.builderBaseLeague,
                      playerTony.name
                    )}
                </div>

                <hr class="card-separator">
                ${createPendingUpgradesSection(playerTony)}
            </div>
          `;

          const tvlDetails = `
            <div class="player-individual-details">
                <h3>${playerTVL.name}</h3>
                <p><strong>XP Level:</strong> 🌟 ${playerTVL.expLevel}</p>
                <p><strong>Trophies:</strong> 🏆 ${playerTVL.trophies} (Best: ${
            playerTVL.bestTrophies
          })</p>
                <p><strong>Attack Wins:</strong> ⚔️ ${playerTVL.attackWins}</p>
                <p><strong>Defense Wins:</strong> 🛡️ ${
                  playerTVL.defenseWins
                }</p>
                <p><strong>War Stars:</strong> ⭐ ${playerTVL.warStars}</p>
                <p><strong>War Preference:</strong> ${
                  playerTVL.warPreference === "in"
                    ? "Participating ✅"
                    : "Not Participating ❌"
                }</p>
                <p><strong>TH Weapon Level:</strong> 💥 Level ${
                  playerTVL.townHallWeaponLevel || "N/A"
                } / ${
            COC_MAX_LEVELS_BY_TH.townHallWeaponLevels[
              playerTVL.townHallLevel
            ] || "N/A"
          }</p>
                <p><strong>Clan Role:</strong> 🤝 ${
                  playerTVL.role
                    ? playerTVL.role.charAt(0).toUpperCase() +
                      playerTVL.role.slice(1)
                    : "Member"
                }</p>
                <p><strong>Builder Hall Level:</strong> 🏠 ${
                  playerTVL.builderHallLevel
                }</p>
                <p><strong>Builder Base Trophies:</strong> 🏅 ${
                  playerTVL.builderBaseTrophies
                } (Best: ${playerTVL.bestBuilderBaseTrophies})</p>
                <p><strong>Clan Capital Contributions:</strong> 💰 ${
                  playerTVL.clanCapitalContributions
                }</p>
                <p><strong>Donations:</strong> 🎁 ${
                  playerTVL.donations
                } (Received: ${playerTVL.donationsReceived})</p>
                
                <hr class="card-separator">

                ${createHeroEquipmentSection(
                  playerTVL.heroEquipment,
                  playerTVL.name
                )}
                ${createAchievementsSection(
                  playerTVL.achievements,
                  playerTVL.name,
                  "home"
                )}
                ${createAchievementsSection(
                  playerTVL.achievements,
                  playerTVL.name,
                  "builderBase"
                )}
                ${createLabelsSection(playerTVL.labels, playerTVL.name)}
                
                <hr class="card-separator">

                <div class="player-details-sub-wrapper">
                    ${createClanDetailsSection(playerTVL.clan, playerTVL.name)}
                    ${createLeagueDetailsSection(
                      playerTVL.league,
                      playerTVL.name
                    )}
                    ${createBuilderBaseLeagueDetailsSection(
                      playerTVL.builderBaseLeague,
                      playerTVL.name
                    )}
                </div>

                <hr class="card-separator">
                ${createPendingUpgradesSection(playerTVL)}
            </div>
          `;

          // Render the final HTML into the container
          container.innerHTML = `
            <h2>Player Comparison: ${playerTony.name} vs ${playerTVL.name}</h2>
            <p>
              <strong>${playerTony.name}</strong> (TH: ${
            playerTony.townHallLevel
          }) vs
              <strong>${playerTVL.name}</strong> (TH: ${
            playerTVL.townHallLevel
          })
            </p>
            ${createComparisonTableSection(
              "Heroes",
              "👑",
              comparisonData.heroes,
              playerTony.name,
              playerTVL.name
            )}
            ${createComparisonTableSection(
              "Troops",
              "⚔️",
              comparisonData.troops,
              playerTony.name,
              playerTVL.name
            )}
            ${createComparisonTableSection(
              "Spells",
              "🧙",
              comparisonData.spells,
              playerTony.name,
              playerTVL.name
            )}

            <hr>

            <h2>Comparative Level Charts</h2>
            <div class="chart-section">
                <h3>📈 Hero Levels</h3>
                <canvas id="heroesChart"></canvas>
            </div>
            <div class="chart-section">
                <h3>⚔️ Troop Levels</h3>
                <canvas id="troopsChart"></canvas>
            </div>
            <div class="chart-section">
                <h3>🧙 Spell Levels</h3>
                <canvas id="spellsChart"></canvas>
            </div>

            <hr>

            <h2>Individual Player Details</h2>
            <div class="individual-details-wrapper">
                ${tonyDetails}
                ${tvlDetails}
            </div>
          `;

          // --- Chart Initialization ---
          setTimeout(() => {
            const heroesChartConfig = generateLevelChartData(
              comparisonData.heroes,
              playerTony.name,
              playerTVL.name
            );
            renderChart(
              document.getElementById("heroesChart"),
              "bar",
              {
                labels: heroesChartConfig.labels,
                datasets: heroesChartConfig.datasets,
              },
              heroesChartConfig.options
            );

            const troopsChartConfig = generateLevelChartData(
              comparisonData.troops,
              playerTony.name,
              playerTVL.name
            );
            renderChart(
              document.getElementById("troopsChart"),
              "bar",
              {
                labels: troopsChartConfig.labels,
                datasets: troopsChartConfig.datasets,
              },
              troopsChartConfig.options
            );

            const spellsChartConfig = generateLevelChartData(
              comparisonData.spells,
              playerTony.name,
              playerTVL.name
            );
            renderChart(
              document.getElementById("spellsChart"),
              "bar",
              {
                labels: spellsChartConfig.labels,
                datasets: spellsChartConfig.datasets,
              },
              spellsChartConfig.options
            );
          }, 100);
        } catch (err) {
          loadingMessage.style.display = "none";

          let errorMessage =
            "An unexpected error occurred while loading data. Please try again later.";

          if (axios.isAxiosError(err)) {
            if (err.response) {
              if (err.response.status === 404) {
                errorMessage =
                  "Error: One or more players not found in the API. Check IDs or names.";
              } else {
                errorMessage = `API Error (${err.response.status}): ${
                  err.response.data?.message ||
                  err.response.statusText ||
                  "Unexpected response"
                }`;
              }
            } else if (err.request) {
              errorMessage =
                "Connection error: Could not reach the API server. Check your internet connection.";
            }
          } else {
            errorMessage = `Internal error: ${err.message}`;
          }

          container.innerHTML = `<p class="error-message">${errorMessage}</p>`;
          console.error("Detailed error:", err);
        }
      })();
    </script>
  </body>
</html>
